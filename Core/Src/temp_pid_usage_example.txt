====================================================================
温度PID控制模块使用示例 - FreeRTOS任务调用
====================================================================

重构后的模块特点：
1. 删除了上电安全延迟功能（由用户自行实现）
2. 占空比使用毫秒数控制（0-1000ms），而非百分比
3. PID计算和MOS管控制分离，方便在FreeRTOS任务中灵活调用

====================================================================
核心函数说明
====================================================================

1. TempCtrl_Init()
   - 初始化温度控制系统
   - 在系统启动时调用一次

2. PID_Compute(PID_Controller_t *pid, float measured_value)
   - 计算PID输出
   - 参数：PID控制器指针、当前温度值
   - 返回：占空比（0-1000ms）

3. MOS_Control(uint16_t duty_ms)
   - 控制MOS管占空比（软件PWM）
   - 参数：1000ms周期内的导通毫秒数（0-1000）
   - 注意：需要以约1ms间隔周期调用

4. TempCtrl_EmergencyStop()
   - 紧急关闭加热

5. TempCtrl_GetPID()
   - 获取PID控制器指针（用于调整PID参数）

====================================================================
FreeRTOS任务示例 - 方案1：单任务模式
====================================================================

void TempControlTask(void const * argument)
{
    float current_temp;
    float pid_output;
    uint16_t duty_ms;
    PID_Controller_t *pid = TempCtrl_GetPID();
    
    // 初始化
    TempCtrl_Init();
    
    // 用户自行实现的上电安全延迟（可选）
    osDelay(5000);  // 延迟5秒
    send_message("[USER] Safety delay complete, starting temperature control\n");
    
    for(;;)
    {
        // 1. 读取当前温度（从NTC或其他传感器）
        current_temp = compute_ntc_temperature(Read_ADC0());
        
        // 2. 温度过高紧急保护
        if (current_temp >= TEMP_EMERGENCY_MAX) {
            send_message("[TEMP] EMERGENCY! Temperature: %.2f°C\n", current_temp);
            TempCtrl_EmergencyStop();
            osDelay(1000);
            continue;
        }
        
        // 3. PID计算（每100ms计算一次）
        pid_output = PID_Compute(pid, current_temp);
        duty_ms = (uint16_t)pid_output;  // 转换为毫秒数
        
        // 4. MOS管控制（每1ms调用一次）
        // 注意：这里演示的是在同一任务中，实际应该使用更精确的定时
        for (int i = 0; i < 100; i++) {
            MOS_Control(duty_ms);
            osDelay(1);  // 1ms延迟
        }
        
        // 5. 打印调试信息（可选）
        send_message("[TEMP] Current: %.2f°C, Target: %.2f°C, Output: %dms\n", 
                    current_temp, TARGET_TEMPERATURE, duty_ms);
    }
}

====================================================================
FreeRTOS任务示例 - 方案2：双任务模式（推荐）
====================================================================

// 任务1：PID计算任务（低频，100ms周期）
void PID_ComputeTask(void const * argument)
{
    float current_temp;
    float pid_output;
    PID_Controller_t *pid = TempCtrl_GetPID();
    
    // 初始化
    TempCtrl_Init();
    
    // 用户自行实现的上电安全延迟
    osDelay(5000);
    send_message("[USER] Safety delay complete\n");
    
    for(;;)
    {
        // 1. 读取当前温度
        current_temp = compute_ntc_temperature(Read_ADC0());
        
        // 2. 温度过高保护
        if (current_temp >= TEMP_EMERGENCY_MAX) {
            TempCtrl_EmergencyStop();
            osDelay(1000);
            continue;
        }
        
        // 3. PID计算
        pid_output = PID_Compute(pid, current_temp);
        
        // 4. 更新全局占空比变量（供MOS控制任务使用）
        g_target_duty_ms = (uint16_t)pid_output;
        
        // 5. 打印调试信息
        send_message("[PID] Temp: %.2f°C, Output: %dms\n", 
                    current_temp, g_target_duty_ms);
        
        // 6. 延迟100ms（PID采样周期）
        osDelay(100);
    }
}

// 任务2：MOS管PWM控制任务（高频，1ms周期）
volatile uint16_t g_target_duty_ms = 0;  // 全局变量

void MOS_ControlTask(void const * argument)
{
    for(;;)
    {
        // 调用MOS控制函数
        MOS_Control(g_target_duty_ms);
        
        // 延迟1ms
        osDelay(1);
    }
}

====================================================================
FreeRTOS任务示例 - 方案3：集成到传感器任务
====================================================================

void Sensors_and_compute(void const * argument)
{
    float temperature;
    float pressure;
    float Temp_NTC;
    uint32_t adcValue;
    float pid_output;
    uint16_t duty_ms;
    PID_Controller_t *pid = TempCtrl_GetPID();
    
    // 初始化温度控制
    TempCtrl_Init();
    
    // 上电安全延迟
    osDelay(5000);
    
    send_message("=== Sensors_and_compute Task Started! ===\n");
    
    for(;;)
    {
        // 1. WF5803F 温度和气压检测
        WF5803F_GetData(&temperature, &pressure);
        send_message("WF5803-Temp: %.2f C, Press: %.2f kPa\n", temperature, pressure);
        
        // 2. NTC 温度检测
        adcValue = Read_ADC0();
        Temp_NTC = compute_ntc_temperature(adcValue);
        send_message("NTC-Temp: %.2fC\n", Temp_NTC);
        
        // 3. 温度保护检查
        if (Temp_NTC >= TEMP_EMERGENCY_MAX) {
            send_message("[TEMP] EMERGENCY! Temperature: %.2f°C\n", Temp_NTC);
            TempCtrl_EmergencyStop();
            osDelay(1000);
            continue;
        }
        
        // 4. PID计算（使用NTC温度作为反馈）
        pid_output = PID_Compute(pid, Temp_NTC);
        duty_ms = (uint16_t)pid_output;
        send_message("[PID] Output: %dms\n", duty_ms);
        
        // 5. MOS管控制（每1ms调用100次，总共100ms）
        for (int i = 0; i < 100; i++) {
            MOS_Control(duty_ms);
            osDelay(1);
        }
    }
}

====================================================================
注意事项
====================================================================

1. MOS_Control() 函数必须以约1ms的间隔周期调用，以实现1000ms周期的软件PWM

2. PID_Compute() 建议按照100ms的间隔调用（可在头文件中修改PID_SAMPLE_TIME_MS）

3. 占空比范围：0-1000ms
   - 0ms：完全关闭加热
   - 1000ms：全功率加热
   - 500ms：50%功率

4. 温度保护：
   - 在调用PID计算前，应检查温度是否超过TEMP_EMERGENCY_MAX
   - 超过则立即调用TempCtrl_EmergencyStop()

5. 上电安全延迟：
   - 已从模块中删除，用户需要在自己的任务中实现
   - 建议延迟3-5秒后再开始温度控制

6. 如需修改PID参数，可使用：
   PID_Controller_t *pid = TempCtrl_GetPID();
   pid->Kp = 新的Kp值;
   pid->Ki = 新的Ki值;
   pid->Kd = 新的Kd值;

====================================================================
